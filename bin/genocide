#!/usr/bin/env python3
# This file is placed in the Public Domain.


import logging
import os
import sys
import threading
import time


sys.path.insert(0, os.getcwd())


from genocide.command import Commands, add, command, parse, scan
from genocide.clients import Client
from genocide.configs import Config, configure
from genocide.defines import SYSTEMD
from genocide.message import Message, reply, wait
from genocide.package import get as mget
from genocide.package import modules
from genocide.threads import launch, threadhook
from genocide.utility import daemon, forever, pidfile, privileges, wrap
from genocide.utility import check, level, spl, wrapped
from genocide.workdir import pidname


"defines"


IGNORE = ""
LOCAL = True
NAME = "genocide" 
VERSION = 221


"clients"


class CLI(Client):

    def __init__(self):
        Client.__init__(self)
        self.register("command", command)

    def raw(self, text):
        print(text.encode('utf-8', 'replace').decode("utf-8"))


class Console(CLI):

    def callback(self, event):
        if not event.text:
            return
        super().callback(event)
        wait(event)

    def poll(self):
        evt = Message()
        evt.text = input("> ")
        evt.kind = "command"
        return evt


"in the beginning"


def banner(name, version):
    tme = time.ctime(time.time()).replace("  ", " ")
    logger = logging.getLogger()
    print("%s %s since %s (%s)" % (
                                   name.upper(),
                                   version,
                                   tme,
                                   logging.getLevelName(logger.getEffectiveLevel())
                                  ))
    sys.stdout.flush()


def scanner(names, init=False):
    mods = []
    for name in names:
        mod = mget(name)
        if mod:
            scan(mod)
        if init and "init" in dir(mod):
            thr = launch(mod.init, Config())
            mods.append((mod, thr))
    return mods


"scripts"


def background():
    daemon(check("v"))
    privileges()
    level("info")
    scanner(modules(), True)
    add(cmd, ver)
    pidfile(pidname(Config.name))
    forever()


def console():
    import readline # noqa: F401
    parse(Config, " ".join(sys.argv[1:]))
    level(Config.sets.get("level", "info"))
    if "v" in Config.opts:
        banner(Config.name, Config.version)
    mods = []
    if "a" in Config.opts:
        mods = modules()
    else:
        mods = spl(Config.sets.get("init", ""))
    add(cmd, ver)
    csl = Console()
    for _mod, thr in scanner(mods, True):
        thr.join(30.0)
    csl.start()
    forever()


def control():
    if len(sys.argv) == 1:
        return
    scanner(modules(), False)
    add(cmd, srv, ver)
    csl = CLI()
    csl.silent = False
    evt = Message()
    evt.orig = repr(csl)
    evt.text = " ".join(sys.argv[1:])
    evt.type = "command"
    command(evt)
    wait(evt)


def service():
    privileges()
    level("info")
    banner(Config.name, Config.version)
    scanner(modules(), True)
    add(cmd, ver)
    pidfile(pidname(Config.name))
    forever()


"commands"


def cmd(event):
    reply(event, ",".join(sorted(Commands.names or Commands.cmds)))


def srv(event):
    import getpass
    name = getpass.getuser()
    reply(event, SYSTEMD % (Config.name.upper(), name, name, name, Config.name))


def ver(event):
    reply(event, f"{Config.name.upper()} {Config.version}")


"runtime"


def main():
    configure(NAME, VERSION, IGNORE, LOCAL)
    if not check("b"):
        threading.excepthook = threadhook
    if check("c"):
        wrap(console)
    elif check("d"):
        background()
    elif check("s"):
        wrapped(service)
    else:
        wrapped(control)


if __name__ == "__main__":
    main()
