#!/usr/bin/env python3
# This file is placed in the Public Domain.


"object runtime"

name = "genocide"


import inspect
import os
import sys
import termios
import time
import threading
import traceback


from obj import Object, get, keys
from obs import Bus
from ocb import Callback
from ocl import Class
from oev import Event
from ofn import register
from ohd import Handler


class Command(Object):

    cmd = Object()

    @staticmethod
    def add(command):
        register(Command.cmd, command.__name__, command)

    @staticmethod
    def get(command):
        f =  get(Command.cmd, command)
        return f

        
class CLI(Handler):

    def cmd(self, txt):
        e = Event()
        e.orig = repr(self)
        e.txt = txt
        self.handle(e)
                
    def raw(self, txt):
        print(txt)


def dispatch(e):
    parse(e, e.txt)
    f = Command.get(e.cmd)
    if f:
        f(e)
        e.show()
    e.ready()


def kcmd(clt, txt):
    if not txt:
        return False
    Callback.add("event", dispatch)
    Bus.add(clt)
    e = Event()
    e.channel = ""
    e.orig = repr(clt)
    e.txt = txt
    clt.handle(e)
    e.wait()
    return e.result


def print_exc(exc):
    traceback.print_exception(type(exc), exc, exc.__traceback__)


def scan(dn):
    nm = dn.split(os.sep)[-1]
    sys.path.insert(0, nm)
    for mn in os.listdir(dn):
        if mn.endswith("~"):
            continue
        if mn.endswith("__"):
            continue
        if mn.endswith(".py"):
            mn = mn[:-3]
        mod = __import__(mn, nm)
        for k, o in inspect.getmembers(mod, inspect.isfunction):
            if "event" in o.__code__.co_varnames:
                Command.cmd[k] = o
        for k, clz in inspect.getmembers(mod, inspect.isclass):
            Class.add(clz)


def wait():
    while 1:
        time.sleep(1.0)
#!/usr/bin/env python3
# This file is placed in the Public Domain.


"object parse"


from obj import Object
from obs import Bus
from ocb import Callback
from obj import Object
from ohd import Handler


class Token(Object):

    pass


class Word(Token):

    def __init__(self, txt=None):
        super().__init__()
        if txt is None:
            txt = ""
        self.txt = txt


class Option(Token):

    def __init__(self, txt):
        super().__init__()
        if txt.startswith("--"):
            self.opt = txt[2:]
        elif txt.startswith("-"):
            self.opt = txt[1:]


class Getter(Token):

    def __init__(self, txt):
        super().__init__()
        if "==" in txt:
            pre, post = txt.split("==", 1)
        else:
            pre = post = ""
        if pre:
            self[pre] = post


class Setter(Token):

    def __init__(self, txt):
        super().__init__()
        if "=" in txt:
            pre, post = txt.split("=", 1)
        else:
            pre = post = ""
        if pre:
            self[pre] = post


class Skip(Token):

    def __init__(self, txt):
        super().__init__()
        pre = ""
        if txt.endswith("-"):
            if "=" in txt:
                pre, _post = txt.split("=", 1)
            elif "==" in txt:
                pre, _post = txt.split("==", 1)
            else:
                pre = txt
        if pre:
            self[pre] = True


class Url(Token):

    def __init__(self, txt):
        super().__init__()
        self.url = ""
        if txt.startswith("http"):
            self.url = txt


def parse(o, ptxt):
    o.txt = ptxt
    o.otxt = ptxt
    o.gets = Object()
    o.opts = Object()
    o.sets = Object()
    o.skip = Object()
    o.timed = []
    o.index = 0
    args = []
    for t in [Word(txt) for txt in ptxt.rsplit()]:
        u = Url(t.txt)
        if u and "url" in u and u.url:
            args.append(u.url)
            t.txt = t.txt.replace(u.url, "")
        s = Skip(t.txt)
        if s:
            update(o.skip, s)
            t.txt = t.txt[:-1]
        g = Getter(t.txt)
        if g:
            update(o.gets, g)
            continue
        s = Setter(t.txt)
        if s:
            update(o.sets, s)
            continue
        opt = Option(t.txt)
        if opt:
            try:
                o.index = int(opt.opt)
                continue
            except ValueError:
                pass
            if len(opt.opt) > 1:
                for op in opt.opt:
                    o.opts[op] = True
            else:
                o.opts[opt.opt] = True
            continue
        args.append(t.txt)
    if not args:
        o.args = []
        o.cmd = ""
        o.rest = ""
        o.txt = ""
        return o
    o.cmd = args[0]
    o.args = args[1:]
    o.txt = " ".join(args)
    o.rest = " ".join(args[1:])
# This file is placed in the Public Domain.


"object command"


import base64
import threading
import time


from obs import Bus
from obj import Object, get, keys, update
from odb import Config, find, last, save
from ofn import edit, format
from oth import getname
from oul import elapsed


starttime = time.time()


def __dir__():
    return (
        "cmd",
        "cfg",
        "dlt",
        "flt",
        "met",
        "mre",
        "nck",
        "ops",
        "pwd",
        "thr"
    )


class Command(Object):

    cmd = Object()

    @staticmethod
    def add(command):
        register(Command.cmd, command.__name__, command)

    @staticmethod
    def get(command):
        f =  get(Command.cmd, command)
        return f


def getmain(name):
    m = __import__("__main__")
    return getattr(m, name, None)


def cfg(event):
    if not event.sets:
        event.reply(format(Config, skip="cc,password,realname,servermodes,sleep,username"))
        return
    edit(Config, event.sets)
    event.reply("ok")


Command.add(cfg)


def cmd(event):
    event.reply(",".join((sorted(keys(Command.cmd)))))


Command.add(cmd)


def dlt(event):
    if not event.args:
        event.reply("dlt <username>")
        return
    selector = {"user": event.args[0]}
    for _fn, o in find("user", selector):
        o._deleted = True
        save(o)
        event.reply("ok")
        break


Command.add(dlt)


def flt(event):
    try:
        index = int(event.args[0])
        event.reply(Bus.objs[index])
        return
    except (KeyError, TypeError, IndexError, ValueError):
        pass
    event.reply(" | ".join([getname(o) for o in Bus.objs]))


Command.add(flt)


def met(event):
    if not event.args:
        event.reply("met <userhost>")
        return
    user = User()
    user.user = event.rest
    user.perms = ["USER"]
    save(user)
    event.reply("ok")


Command.add(met)


def mre(event):
    if event.channel is None:
        event.reply("channel is not set.")
        return
    bot = event.bot()
    if "cache" not in bot:
        event.reply("bot is missing cache")
        return
    if event.channel not in bot.cache:
        event.reply("no output in %s cache." % event.channel)
        return
    for _x in range(3):
        txt = bot.cache[event.channel].pop(0)
        if txt:
            bot.say(event.channel, txt)
    sz = bot.size(event.channel)
    if sz:
        event.reply("(+%s more)" % sz)


Command.add(mre)


def pwd(event):
    if len(event.args) != 2:
        event.reply("pwd <nick> <password>")
        return
    m = "\x00%s\x00%s" % (event.args[0], event.args[1])
    mb = m.encode("ascii")
    bb = base64.b64encode(mb)
    bm = bb.decode("ascii")
    event.reply(bm)


Command.add(pwd)


def thr(event):
    result = []
    for t in sorted(threading.enumerate(), key=lambda x: x.getName()):
        if str(t).startswith("<_"):
            continue
        o = Object()
        update(o, vars(t))
        if get(o, "sleep", None):
            up = o.sleep - int(time.time() - o.state.latest)
        else:
            up = int(time.time() - starttime)
        result.append((up, t.getName()))
    res = []
    for up, txt in sorted(result, key=lambda x: x[0]):
        res.append("%s(%s)" % (txt, elapsed(up)))
    if res:
        event.reply(" ".join(res))


Command.add(thr)
#!/usr/bin/env python3
# This file is placed in the Public Domain.


"object execute"


import os
import readline
import sys
import termios
import time


from ocb import Callback
from odb import Config
from ohd import Handler


from genocide.mdl import init


def wrap(func):
    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    try:
        func()
    except (EOFError, KeyboardInterrupt):
        print("")
    finally:
        for exc in Callback.errors:
            print_exc(exc)
        termios.tcsetattr(fd, termios.TCSADRAIN, old)



def main():
    Config.workdir = os.path.expanduser("~/.%s" % name)
    Config.name = name
    scan("genocide")
    c = CLI()
    kcmd(c, " ".join(sys.argv[1:]))


wrap(main)
