#!/usr/bin/env python3
# This file is placed in the Public Domain.


import importlib
import os
import shutil
import sys
import termios
import time
import traceback


sys.path.insert(0, os.getcwd())


from genocide import Callback, Default, Object, Wd,  elapsed, keys, name, printable
from genocide import Command, Event, Handler, parse, scandir, scan, launch
from genocide import update


Wd.workdir = ".test"


events = []
results = []
starttime = time.time()
stopmarkers = ['python', 'genocide', 'src', 'lib', 'bin']


param = Object()
param.cfg = ["server=localhost"]
param.cmd = [""]
param.cor = ["bthate@gmail.com"]
param.dlt = ["test@shell"]
param.dne = ["test4"]
param.dpl = ["reddit title,summary,link"]
param.eml = ["bthate@gmail.com"]
param.flt = ["", "0"]
param.ftc = [""]
param.log = ["test1"]
param.mbx = ["~/25-01-2013"]
param.met = ["test@shell"]
param.mre = [""]
param.nme = ["reddit reddit"]
param.pwd = ["bart test"]
param.rem = ["reddit"]
param.rss = ["https://www.reddit.com/r/python/.rss"]
param.sts = [""]
param.tdo = ["test4", ""]
param.thr = [""]
param.upt = [""]



Cfg = Default()


def cprint(txt):
    print(txt)
    sys.stdout.flush()


class CLI(Handler):

    def say(self, channel, txt):
        if Cfg.verbose:
            cprint(txt)


def callstack(frame):
    result = []
    loopframe = frame
    while 1:
        try:
            filename = loopframe.f_back.f_code.co_filename
            plugfile = filename.split(os.sep)
            if plugfile:
                mod = []
                stop = False
                for i in plugfile[::-1]:
                    next = False
                    for stp in stopmarkers:
                        if stp in i:
                            stop = True
                            break
                    if stop:
                        break
                    mod.append(i)
                modstr = os.sep.join(mod[::-1])
                if not modstr:
                    modstr = plugfile
            result.append("%s:%s" % (modstr, loopframe.f_back.f_lineno))
            loopframe = loopframe.f_back
        except:
            break
    del frame
    return result


def consume(evts):
    fixed = []
    res = []
    for evt in evts:
        evt.wait()
        fixed.append(evt)
    for fix in fixed:
        try:
            evts.remove(fix)
        except ValueError:
            continue
    return res


def from_exception(exc, txt="", sep=" "):
    result = []
    for frm in traceback.extract_tb(exc.__traceback__):
        fnm = os.sep.join(frm.filename.split(os.sep)[-2:])
        result.append(f"{fnm}:{frm.lineno}")
    nme = name(exc)
    res = sep.join(result)
    fromm = where(exc.__traceback__.tb_frame)
    if txt:
        return f"{fromm} {txt} {res} {nme}: {exc}"
    return f"{fromm} {res} {nme}: {exc}"
    

def importer(packagename, modulename):
    name = "%s.%s" % (packagename, modulename)
    try:
        mod = importlib.import_module(name, packagename)
        scan(mod)
    except Exception as ex:
        Callback.errors.append(ex)


def payload(cli):
    cmds = sorted(Command.cmd)
    _nr = 0
    for cmd in cmds:
        for ex in getattr(param, cmd, [""]):
            evt = Event()
            evt.txt = cmd + " " + ex
            evt.orig = repr(cli)
            evt.parse()
            #cli.put(evt)
            cli.handle(evt)
            events.append(evt)
            _nr += 1
    return _nr


def where(frm=None, depth=0):
    return " ".join(callstack(frm or sys._getframe(depth)))


def wrap(func):
    fds = sys.stdin.fileno()
    old = termios.tcgetattr(fds)
    try:
        func()
    except (EOFError, KeyboardInterrupt):
        cprint("")
    finally:
        termios.tcsetattr(fds, termios.TCSADRAIN, old)
    for err in Callback.errors:
        cprint(from_exception(err))


def main():
    if os.path.exists(Wd.workdir):
        shutil.rmtree(Wd.workdir)
    txt = " ".join(sys.argv[1:])
    cfg = parse(txt)
    update(Cfg, cfg)
    if "v" in cfg.opts:
        Cfg.verbose = True
    scandir("genocide", importer)
    cli = CLI()
    cli.start()
    nrs = cfg.index or 1
    res = 1
    thrs = []
    for _nr in range(nrs):
        thrs.append(launch(payload, cli))
    if thrs:
        for thr in thrs:
            res += thr.join()
    else:
        res = nrs * len(Command.cmd)
    if not res:
        res = 1
    consume(events)
    endtime = time.time()
    print("%s %s %s (%s remaining)" %  (
                                        elapsed(endtime - starttime),
                                        res,
                                        (endtime - starttime)/res, len(events))
                                       )


wrap(main)
